#include "social_nav_plugin/social_critic.hpp"
#include "nav2_util/node_utils.hpp"
#include "pluginlib/class_list_macros.hpp"
#include <cmath>

namespace social_nav_plugin
{

void SocialCritic::onInit()
{
  auto node = node_.lock();
  if (!node) {
    throw std::runtime_error{"Failed to lock node"};
  }

  // Subscribe to /openai_result
  social_sub_ = node->create_subscription<vlm_social_nav::msg::SocialNavMsg>(
    "/openai_result", rclcpp::SystemDefaultsQoS(),
    std::bind(&SocialCritic::socialCallback, this, std::placeholders::_1));

  RCLCPP_INFO(node->get_logger(), "SocialCritic initialized");
}

void SocialCritic::socialCallback(const vlm_social_nav::msg::SocialNavMsg::SharedPtr msg)
{
  std::lock_guard<std::mutex> lock(social_mutex_);
  try {
    head_dir_ = std::stoi(msg->head_dir);
    speed_ = std::stoi(msg->speed);
    RCLCPP_INFO(node_.lock()->get_logger(), "Received Social Cmd: %d, %d", head_dir_, speed_);
  } catch (...) {
    head_dir_ = -1;
    speed_ = -1;
  }
}

bool SocialCritic::prepare(const geometry_msgs::msg::Pose2D & /*pose*/, const nav_2d_msgs::msg::Twist2D & /*vel*/,
  const geometry_msgs::msg::Pose2D & /*goal*/,
  const nav_2d_msgs::msg::Path2D & /*global_plan*/)
{
  return true;
}

void SocialCritic::reset()
{
  std::lock_guard<std::mutex> lock(social_mutex_);
  head_dir_ = -1;
  speed_ = -1;
}

double SocialCritic::scoreTrajectory(const dwb_msgs::msg::Trajectory2D & traj)
{
  std::lock_guard<std::mutex> lock(social_mutex_);
  
  const double TURN_COST_WEIGHT = 10.0;
  const double SPEED_COST_WEIGHT = 5.0;
  double cost = 0.0;

  //  no social cost recieved
  if (head_dir_ < 0 || speed_ < 0)
      return 0.0;

  double xv = traj.velocity.x;
  double thetav = traj.velocity.theta;
  
  if (speed_ == 3) {
      // STOP
      return std::abs(xv) * 100.0;
  }

  // ROS 1 iterates over points. 
  // Trajectory cost accumulates per point in time step.
  // We should do the same to match magnitude of cost if we want to be consistent?
  // Or at least match the behavior that longer trajectories accumulate more cost?
  // ROS 1 DWA Loop: for (i=0; i<traj.getPointsSize(); ++i) cost += ...
  // DWA points are generated by sim_time / sim_granularity.
  
  int num_points = traj.poses.size();
  
  for (int i = 0; i < num_points; ++i) {
      double desired_theta = 0.0;
      double desired_speed = 0.0;
      
      // preference on the left
      // In original code: 1 is STRAIGHT, mapped to 0.2 (Turn Left)
      if (head_dir_ == 1) 
          desired_theta = 0.2;
      // preference on the straight
      // In original code: 0 is LEFT, mapped to 0.0 (Straight)
      else if (head_dir_ == 0) 
          desired_theta = 0.0;
      // preference on the right
      // In original code: 2 is RIGHT, mapped to -0.2 (Turn Right)
      else if (head_dir_ == 2) 
          desired_theta = -0.2;

      cost += TURN_COST_WEIGHT * std::abs(desired_theta - thetav);

      // speed lookup
      if (speed_ == 0) 
          desired_speed = 0.3;
      else if (speed_ == 1) 
          desired_speed = 0.6;
      else if (speed_ == 2)
          desired_speed = 0.4;
      // speed_ == 3 handled above
      
      cost += SPEED_COST_WEIGHT * std::abs(desired_speed - xv);
  }

  return cost;
}

}  // namespace social_nav_plugin

PLUGINLIB_EXPORT_CLASS(social_nav_plugin::SocialCritic, dwb_core::TrajectoryCritic)
